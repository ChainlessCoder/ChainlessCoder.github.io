<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Demystifying Sparse Merkle Trees üå≤ | Lum Ramabaja</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="Hypersyn: A Peer-to-Peer System for Mutual Credit">
<meta name="generator" content="Hugo 0.97.3" />


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />

 
    



  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>




  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">‚Üê</span>Home</a>
	
	<a href="/posts">Archive</a>
	<a href="/tags">Tags</a>
	<a href="/about">About</a>

	

	
	  <a class="button" href="https://chainlesscoder.com/index.xml">Subscribe</a>
	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">Demystifying Sparse Merkle Trees üå≤</h1>

    <div class="tip">
        <time datetime="2022-08-18 00:00:00 &#43;0000 UTC">Aug 18, 2022</time>
        <span class="split">
          ¬∑
        </span>
        <span>
          1227 words
        </span>
        <span class="split">
          ¬∑
        </span>
        <span>
          6 minute read
        </span>
    </div>

    
    
        
  


    


    <div class="content">
      <p>This is part 2 of the Hypersyn blog series. Visit <a href="https://chainlesscoder.com/posts/hypersyn-a-peer-to-peer-system-for-mutual-credit/" target="_blank" rel="noopener">part 0</a> to explore the other parts of the blog series. To read the whole Hypersyn blog series in PDF form with included references, visit <a href="https://arxiv.org/pdf/2206.04049.pdf" target="_blank" rel="noopener">arxiv</a>.</p>
<hr>
<p>A Merkle tree is a binary tree data structure used to securely verify the presence of values in a list, without having to provide every value of the list to another party. To construct a Merkle tree, every value is hashed via a cryptographic hash function, the transformed values are also known as <em>leaf nodes</em>. The leaf nodes are then hashed together to form parent nodes, also known as <em>non-leaf nodes</em>. This step is repeated until the root of the constructed binary tree is reached (see Figure 1.).</p>
<p align="center">
 <img width="70%" height="70%" src="/images/2022/merkle_tree.png">
 <em><br/>Figure 1. A depiction of a Merkle Tree. Leaf nodes are represented in yellow. Non-leaf nodes are represented in blue.</em>
</p>
<p>To verify that a value is present in the Merkle tree, a series of hashes (also known as the <em>Merkle proof</em>) is provided. By sequentially hashing the leaf node hash with the provided Merkle proof, the Merkle root of the original Merkle tree can be recreated (see Figure 2.). Note that recipients of a Merkle proof must already have a local copy of the Merkle root for a proof to take place. A node that receives a Merkle proof therefore, is able to verify if a value was part of the list of values that generated the Merkle root, by comparing their locally stored Merkle root, with the final hash generated by the provided Merkle proof. If the two hashes are equivalent, then the recipient of the Merkle proof knows that the provided value was indeed one of the leaf nodes in the original Merkle tree. This is also known as a <em>presence proof</em>. Instead of having to provide the whole list of $M$ values to another party to verify the presence of one specific value, Merkle trees allow to prove the presence of a value by providing only <em>log(M)</em> hashes.</p>
<p align="center">
 <img width="70%" height="70%" src="/images/2022/merkle_proof.png">
 <em><br/>Figure 2. A depiction of a Merkle proof. To prove that <b>H<sub>3</sub></b> was present in the initial value list, one has to hash it with <b>H<sub>4</sub></b>, then with <b>H<sub>1,2</sub></b>, and finally with <b>H<sub>5,6,7,8</sub></b> (shown in green) to recreate the hash of the Merkle root.</em>
</p>
<p>While Merkle trees can provide presence proofs and perform value insertions with <em>log(M)</em> steps, they do not allow for efficient <em>absence proofs</em>, value updates, and value deletions. An absence proof is when a Merkle proof can show the absence of a value in a tree. In regular Merkle trees, absence proofs require leaf node sorting, while value updates and deletions require the re-computation of the whole tree, all of which are computationally expensive. The sparse Merkle tree (SMT) solves these issues by slightly redefining how a tree is constructed. In the SMT, one can both provide presence and absence proofs in <em>log(M)</em> steps on average, as well as perform insertions, deletions, and updates in <em>log(M)</em> steps on average.</p>
<p>Instead of constructing a Merkle tree bottom-up from a fixed set of values, SMTs start with an empty tree and sequentially add values to it. This is done by introducing the concept of <em>empty nodes</em> (a constant node with a fixed hash value), as well as by following a simple heuristic:</p>
<ul>
<li>To add a new value to the tree, begin from the tree root. If there is no value yet in the tree, let the tree root be the empty node.</li>
<li>Let the path from a parent node to the left child node represent a zero, and the path to the right child node represent a one (see Figure 3.). Every value has a bit sequence (their cryptographic hash) that can be mapped onto the tree by sequentially choosing either the left side, or right side of a parent node, depending on the bits of the value&rsquo;s hash. Go down the value&rsquo;s path in the tree until a leaf node, or an empty node is reached.</li>
<li>If an empty node is reached, substitute it with the new value. Taking Figure 3. as an example, inserting the orange value with ID <strong>100</strong> (at time step <strong>t<sub>2</sub></strong>) will result in the substitution of an empty node with the actual value.</li>
<li>If a leaf node is reached, create two child nodes and remap the values (by looking at the hashes of the values). If the values get mapped to the same child node, repeat the process and insert an empty node at the opposite child node. Taking Figure 3. as an example, inserting the yellow value with ID <strong>011</strong> (at time step <strong>t<sub>3</sub></strong>) will result in the repositioning of the value with ID <strong>010</strong>, as well as result in the creation of an empty node on the left side of the none-leaf node that was previously (in time step <strong>t<sub>2</sub></strong>) the <strong>010</strong> leaf node.</li>
</ul>
<p align="center">
 <img width="80%" height="80%" src="/images/2022/smt_insertion.png">
 <em><br/>Figure 3. A depiction of a sparse Merkle tree. At every time step <b>t</b> a value is being inserted. Blue nodes represent non-leaf nodes. White nodes with full lines represent empty nodes. White nodes with dashed lines are not part of the SMT and serve to depict where value nodes in the tree would get mapped. The green (<b>010</b>), orange (<b>100</b>), and yellow (<b>010</b>) nodes represent the values, i.e. leaf nodes of the SMT.</em>
</p>
<p>Value deletions in SMTs work the exact same way as insertions, but in reverse. When removing a leaf node we move any sibling node up, until a parent node with another leaf node, or empty node is reached. Proving the presence of a value in SMTs is done the same way as in regular Merkle trees (see Figure 2. as reference), but surprisingly enough, so are absence proofs. To prove that a value was not part of a sparse Merkle tree, all one has to do is provide a regular Merkle proof, where the original leaf value of the proof represents the empty node value (a constant hash value). Taking Figure 4. as an example, to prove that the value with ID <strong>001</strong> (depicted with a yellow dashed line) is not part of the SMT, one simply has to provide the empty node, as well as the green leaf node and the orange leaf node to a recipient. By hashing the empty node value with the green node value and the orange node value, one recreates the original Merkle root and can therefore prove that any value that starts with <strong>01</strong> cannot have been part of the tree.</p>
<p align="center">
 <img width="80%" height="80%" src="/images/2022/smt_absence_proof.png">
 <em><br/>Figure 4. A depiction of a sparse Merkle tree. the value with ID <b>011</b> was never inserted into the SMT. One can show this by generating an absence proof.</em>
</p>
<p>In agent-centric protocol designs, nodes usually sign their Merkle roots with their private keys before sending it to peers. This is done to prevent malicious peers from forging another node&rsquo;s Merkle roots. When the volume of requests on a node-basis is high however, that is, when a node has to update, insert, and/or delete many of its SMT values in a small amount of time, signing the Merkle root after every state change becomes costly. To overcome this scalability issue, nodes in Hypersyn can batch-sign a number of transactions (i.e. SMT state changes) by signing a single Merkle root and a counter, as long as the state changes have a partial order with each other (see <a href="https://chainlesscoder.com/posts/hypersyn-mechanism-overview" target="_blank" rel="noopener">part 3</a>).</p>
    </div>

    
        <div class="tags">
            
                <a href="https://chainlesscoder.com/tags/data-structures">data structures</a>
            
        </div>
    
    
    
  <div id="comment">
    
    
  </div>


</section>


    </main>
    
    <footer id="footer">
    
        <div id="social">


    <a class="symbol" href="https://github.com/ChainlessCoder" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28"  viewBox="0 0 72 72" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    
    <title>Github</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)">
            <g id="Github" transform="translate(264.000000, 939.000000)">
                <path d="M8,72 L64,72 C68.418278,72 72,68.418278 72,64 L72,8 C72,3.581722 68.418278,-8.11624501e-16 64,0 L8,0 C3.581722,8.11624501e-16 -5.41083001e-16,3.581722 0,8 L0,64 C5.41083001e-16,68.418278 3.581722,72 8,72 Z" id="Rounded" fill="#bbbbbb"></path>
                <path d="M35.9985,13 C22.746,13 12,23.7870921 12,37.096644 C12,47.7406712 18.876,56.7718301 28.4145,59.9584121 C29.6145,60.1797862 30.0525,59.4358488 30.0525,58.7973276 C30.0525,58.2250681 30.0315,56.7100863 30.0195,54.6996482 C23.343,56.1558981 21.9345,51.4693938 21.9345,51.4693938 C20.844,48.6864054 19.2705,47.9454799 19.2705,47.9454799 C17.091,46.4500754 19.4355,46.4801943 19.4355,46.4801943 C21.843,46.6503662 23.1105,48.9634994 23.1105,48.9634994 C25.2525,52.6455377 28.728,51.5823398 30.096,50.9649018 C30.3135,49.4077535 30.9345,48.3460615 31.62,47.7436831 C26.2905,47.1352808 20.688,45.0691228 20.688,35.8361671 C20.688,33.2052792 21.6225,31.0547881 23.1585,29.3696344 C22.911,28.7597262 22.0875,26.3110578 23.3925,22.9934585 C23.3925,22.9934585 25.4085,22.3459017 29.9925,25.4632101 C31.908,24.9285993 33.96,24.6620468 36.0015,24.6515052 C38.04,24.6620468 40.0935,24.9285993 42.0105,25.4632101 C46.5915,22.3459017 48.603,22.9934585 48.603,22.9934585 C49.9125,26.3110578 49.089,28.7597262 48.8415,29.3696344 C50.3805,31.0547881 51.309,33.2052792 51.309,35.8361671 C51.309,45.0917119 45.6975,47.1292571 40.3515,47.7256117 C41.2125,48.4695491 41.9805,49.9393525 41.9805,52.1877301 C41.9805,55.4089489 41.9505,58.0067059 41.9505,58.7973276 C41.9505,59.4418726 42.3825,60.1918338 43.6005,59.9554002 C53.13,56.7627944 60,47.7376593 60,37.096644 C60,23.7870921 49.254,13 35.9985,13" fill="#FFFFFF"></path>
            </g>
        </g>
    </g>
</svg>
    </a>


</div>

    

    <div class="copyright">
    
       ¬© Copyright 
       2025 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       Lum Ramabaja
    
    </div>

    
</footer>



  </body>
</html>
