<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Let It Bloom: The Seeds of Information Chaining (Part 1) | Lum Ramabaja</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="Let It Bloom: The Seeds of Information Chaining (Part 1)">
<meta name="generator" content="Hugo 0.97.3" />


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">


  
    
    <link rel="stylesheet" href="https://lumramabaja.comcss/custom.css">
  


<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />

 
    



  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false},
                {left: "\\(", right: "\\)", display: false},
                {left: "\\[", right: "\\]", display: true}
            ]
        });
    });
</script>





  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">‚Üê</span>Home</a>
	
	<a href="/posts">Archive</a>
	<a href="/tags">Tags</a>
	<a href="/about">About</a>

	

	
	  <a class="button" href="https://lumramabaja.com/index.xml">Subscribe</a>
	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">Let It Bloom: The Seeds of Information Chaining (Part 1)</h1>

    <div class="tip">
        <time datetime="2026-01-19 00:00:00 &#43;0000 UTC">Jan 19, 2026</time>
        <span class="split">
          ¬∑
        </span>
        <span>
          7099 words
        </span>
        <span class="split">
          ¬∑
        </span>
        <span>
          34 minute read
        </span>
    </div>

    
    
        
  
    <aside class="toc">
      <details>
          <summary>Table of Contents
          </summary>
          <div>
              <nav id="TableOfContents">
  <ul>
    <li><a href="#bloom-filters">Bloom Filters</a></li>
    <li><a href="#the-seeds-of-information-chaining">The Seeds of Information Chaining</a>
      <ul>
        <li><a href="#encoding-data-into-a-bloom-filter">Encoding data into a Bloom filter</a></li>
        <li><a href="#decoding-finding-the-correct-path">Decoding: finding the correct path</a>
          <ul>
            <li><a href="#paths-trees-and-probabilities">Paths, trees, and probabilities</a></li>
            <li><a href="#why-the-false-positive-rate-matters">Why the false positive rate matters</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#from-chaining-to-erasure-coding">From Chaining to Erasure Coding</a>
      <ul>
        <li><a href="#the-promise-of-erasure-codes">The promise of erasure codes</a></li>
        <li><a href="#designing-a-bloom-filterbased-erasure-encoder">Designing a Bloom filter‚Äìbased erasure encoder</a></li>
        <li><a href="#decoding-with-erasures">Decoding with erasures</a></li>
        <li><a href="#the-role-of-the-chain-header">The role of the chain header</a></li>
      </ul>
    </li>
    <li><a href="#reflection-and-teasers">Reflection and teasers</a></li>
    <li><a href="#how-to-cite-this-work">How to Cite This Work</a></li>
  </ul>
</nav>
          </div>
      </details>
    </aside>
  


    


    <div class="content">
      <p style="margin: 0; padding: 0;" align="center">
  <img 
    src="/images/information_chaining_part_1/banner.jpg" 
    alt="Let it Bloom" 
    style="width: 100%; height: auto; display: block;">
</p>

<hr>
<p>‚ÄúInformation Chaining‚Äù is a new family of erasure codes developed at <a href="https://opencybernetics.io" target="_blank" rel="noopener">Open Cybernetics</a>. Some variants are rateless; others are fixed-rate. In this series, we‚Äôll explore the different <em>flavors</em> of Information Chaining. While later versions are substantially more performant and no longer rely on approximate membership query (AMQ) filters, we begin with the Bloom filter‚Äìbased variant because it offers the most intuitive entry point into the core idea. It‚Äôs also how the concept originally came about.</p>
<p>Throughout the series, I‚Äôll include examples written in <a href="https://ziglang.org/" target="_blank" rel="noopener">Zig</a> (version <code>0.15.2</code>). All the code shown here is open source; you can find it in the blog‚Äôs GitHub <a href="link">repository</a>. If you‚Äôd like to learn more about our work and philosophy, visit <a href="https://blog.opencybernetics.io/post/who_holds_the_control/" target="_blank" rel="noopener">our blog</a>. And if Zig sparks joy for you the way it does for us, consider supporting the <a href="https://ziglang.org/zsf/" target="_blank" rel="noopener">Zig Software Foundation</a>.</p>
<h1 id="bloom-filters">Bloom Filters <a href="#bloom-filters" class="anchor">üîó</a></h1><p>Before we continue, let‚Äôs refresh our understanding of what Bloom filters are and how they work. A Bloom filter is a simple, space-efficient probabilistic data structure that allows us to quickly test whether an element is part of a set. Initialization is straightforward: we define a bit array of size $m$, initialized with all bits set to zero, and select $k$ independent hash functions. These hash functions don‚Äôt need to be cryptographically secure, just fast and reasonably uniform. To populate a Bloom filter, we perform the following steps:</p>
<ul>
<li>Hash an element using the $k$ hash functions, generating $k$ hashes.</li>
<li>Take each hash modulo $m$ to ensure the resulting values fall within the range <code>[0, m)</code>.</li>
<li>Use these $k$ values as indices into the bit array, setting the bits at those positions from <code>0</code> to <code>1</code> (see Figure 1).</li>
<li>Repeat the process for each element to be inserted.</li>
</ul>
<p align="center">
 <img width="100%" height="100%" src="/images/information_chaining_part_1/bloom_filter_1.svg">
 <em><br/>Figure 1. Adding an element to a Bloom filter.</em>
</p>
<p>To check whether an element is present, we hash it $k$ times and look up the corresponding bits. If any of the $k$ bits is <code>0</code>, we can be certain that the element was never inserted, this is why false negatives are impossible in a Bloom filter. However, this efficiency comes at a cost: the structure is probabilistic. While Bloom filters can never produce false negatives, they <em>can</em> produce false positives, cases where the filter indicates that an element <em>might</em> be in the set, even when it isn‚Äôt.</p>
<p>To see how this happens, let‚Äôs look at Figure 2. Here, elements $Y$ and $Z$ have been added to the filter. Checking for them shows that all corresponding bits are set to <code>1</code>, so we correctly conclude that they‚Äôre present. But if we check for element $X$, which was never inserted, we might find that its $k$ bit positions are also all <code>1</code>, not because $X$ was added, but because its indices overlap with those of $Y$ and $Z$. That overlap leads to a false positive.</p>
<p align="center">
 <img width="100%" height="100%" src="/images/information_chaining_part_1/bloom_filter_2.svg">
 <em><br/>Figure 2. A depiction of a false positive match during a Bloom filter lookup.</em>
</p>
<p>Fortunately, the false positive rate can be controlled by adjusting the Bloom filter‚Äôs parameters:</p>
<p>$$p = \left(1-\left(1-\frac{1}{m}\right)^{kn}\right)^k \approx \left(1-e^{-\frac{kn}{m}} \right)^k$$</p>
<p>Here:</p>
<ul>
<li>$n$ = number of inserted elements</li>
<li>$m$ = number of bits in the filter</li>
<li>$k$ = number of hash functions</li>
</ul>
<p>We can reduce the false positive rate $p$ by increasing $m$ and $k$, or by decreasing $n$. The optimal values for $m$ and $k$, given a target false positive rate $p$ and element count $n$, are derived as:</p>
<p>$$ m = -\frac{n\ln(p)}{\ln(2)^2}; \qquad k = \frac{m}{n}\ln(2) $$</p>
<p>While the derivation of these formulas is elegant, it‚Äôs also a bit math-heavy. If you‚Äôd like to dive into the derivation, see the <a href="https://en.wikipedia.org/wiki/Bloom_filter#Probability_of_false_positives" target="_blank" rel="noopener">Wikipedia section</a> on Bloom filter false positives.</p>
<p>For the hands-on reader, I‚Äôve included a special Bloom filter implementation in Zig (<em>Code Example 1</em>). This version isn‚Äôt a conventional Bloom filter and isn‚Äôt optimized for performance. Unlike the standard algorithm, it has a strange way to insert items. The reason for this unusual design choice will become clear in the next section.</p>
<div class="code-frame">
    <div class="code-frame__title">Code Example 1. Simplified Bloom Filter</div>
  <div class="code-frame__body"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#ff79c6">const</span> std <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@import</span>(<span style="color:#f1fa8c">&#34;std&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">const</span> Allocator <span style="color:#ff79c6">=</span> std.mem.Allocator;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> SimplifiedFilter(
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">comptime</span> T<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">type</span>,
</span></span><span style="display:flex;"><span>) <span style="color:#8be9fd">type</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> Self <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@This</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        filter<span style="color:#ff79c6">:</span> []<span style="color:#8be9fd">u8</span>,
</span></span><span style="display:flex;"><span>        m<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> init(allocator<span style="color:#ff79c6">:</span> Allocator, byte_num<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>) <span style="color:#ff79c6">!</span>Self {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> memory <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">try</span> allocator.alloc(<span style="color:#8be9fd">u8</span>, byte_num);
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">@memset</span>(memory, <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> .{ .filter <span style="color:#ff79c6">=</span> memory, .m <span style="color:#ff79c6">=</span> byte_num <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">8</span> };
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> deinit(self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span>Self, allocator<span style="color:#ff79c6">:</span> Allocator) <span style="color:#8be9fd">void</span> {
</span></span><span style="display:flex;"><span>            allocator.free(self.filter);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> insert(self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span>Self, item<span style="color:#ff79c6">:</span> T) <span style="color:#8be9fd">void</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> bit_index <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@as</span>(<span style="color:#8be9fd">usize</span>, <span style="color:#8be9fd;font-style:italic">@intCast</span>(item)) <span style="color:#ff79c6">%</span> self.m;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> byte_index <span style="color:#ff79c6">=</span> bit_index <span style="color:#ff79c6">/</span> <span style="color:#bd93f9">8</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> bit_offset<span style="color:#ff79c6">:</span> u3 <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@intCast</span>(bit_index <span style="color:#ff79c6">%</span> <span style="color:#bd93f9">8</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> mask<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">u8</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@as</span>(<span style="color:#8be9fd">u8</span>, <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">&lt;&lt;</span> bit_offset;
</span></span><span style="display:flex;"><span>            self.filter[byte_index] <span style="color:#ff79c6">|=</span> mask;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> contains(self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> Self, item<span style="color:#ff79c6">:</span> T) <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> bit_index <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@as</span>(<span style="color:#8be9fd">usize</span>, <span style="color:#8be9fd;font-style:italic">@intCast</span>(item)) <span style="color:#ff79c6">%</span> self.m;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> byte_index <span style="color:#ff79c6">=</span> bit_index <span style="color:#ff79c6">/</span> <span style="color:#bd93f9">8</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> bit_offset<span style="color:#ff79c6">:</span> u3 <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@intCast</span>(bit_index <span style="color:#ff79c6">%</span> <span style="color:#bd93f9">8</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> mask<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">u8</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@as</span>(<span style="color:#8be9fd">u8</span>, <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">&lt;&lt;</span> bit_offset;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> (self.filter[byte_index] <span style="color:#ff79c6">&amp;</span> mask) <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
  </div>
</div>

<h1 id="the-seeds-of-information-chaining">The Seeds of Information Chaining <a href="#the-seeds-of-information-chaining" class="anchor">üîó</a></h1><p>Let us now tinker.</p>
<p>We know that we can insert elements into a Bloom filter and then check, in a space-efficient way, whether an element <em>might</em> be in it. These cheap lookups are used everywhere, in databases (LSM trees), in set reconciliation, in the Bitcoin protocol, in genomics (k-mer lookups), and more. But what if we go beyond space-efficient <em>lookups</em>? What if we could not only verify the absence of elements via Bloom filters, but also store data within them, effectively encoding information into a Bloom filter, and later decoding it back to its original form? Why would we even want to do that? For now, let‚Äôs not worry about the <em>why</em>. We‚Äôre just tinkering. The <em>why</em> will reveal itself soon.</p>
<h2 id="encoding-data-into-a-bloom-filter">Encoding data into a Bloom filter <a href="#encoding-data-into-a-bloom-filter" class="anchor">üîó</a></h2><p>How might we encode an entire sequence of symbols into a Bloom filter? A natural first attempt might be to <em>insert each symbol</em> of the sequence into the Bloom filter. But that alone doesn‚Äôt capture order or repetition. A second idea could be to insert each symbol <em>together with its index position</em>. That‚Äôs better, but not enough. Because Bloom filters are probabilistic, collisions will occur: depending on the false positive rate and bit size, several symbols might appear to belong to the same position. Without prior knowledge of the input distribution, we couldn‚Äôt reliably recover the original message. No, we need something different. Something cleaner.</p>
<p>To keep things simple, let‚Äôs treat each bit of the original message as a separate symbol (We‚Äôll deal with multi-bit symbols later). Now, in all Bloom filter variants, one thing is constant: each lookup is independent. If we inserted symbols along with their index positions, checking whether the bit at position $N$ is present would tell us nothing about the bit at position $N + 1$. But what if we could turn those independent probabilities into conditional probabilities? <em>What if we &ldquo;chain&rdquo; the insertions</em>? This simple realization is the seed for Information Chaining.</p>
<p>Let‚Äôs walk through <em>Code Example 2</em> to understand how encoding works in a Bloom filter‚Äìbased Information Chaining implementation. Imagine a state machine with an initial state, a <em>nonce</em>, which could be a random value, a counter, an empty state, or something derived from a public key. We‚Äôll refer to the current state of this machine as the chain header. For simplicity, we‚Äôll treat it as a <code>usize</code> for now; later, we‚Äôll explore how its type influences performance and behavior. We then iterate over the message and perform the following steps:</p>
<ol>
<li>Take the current source symbol (a bit) of the message that we want to encode.</li>
<li>Update the chain header by mixing the current chain header with the symbol. Any fast, random-looking mixing function will do, the goal is to evolve the state unpredictably.</li>
<li>Insert the new chain header into the simplified filter, turning the corresponding bit(s) from <code>0</code> to <code>1</code>.</li>
</ol>
<p>After processing all the source symbols, we end up with a populated filter that represents an encoding.</p>
<div class="code-frame">
    <div class="code-frame__title">Code Example 2. Information Chaining Encoder</div>
  <div class="code-frame__body"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#ff79c6">const</span> std <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@import</span>(<span style="color:#f1fa8c">&#34;std&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">const</span> SimplifiedFilter <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@import</span>(<span style="color:#f1fa8c">&#34;simplified_filter.zig&#34;</span>).SimplifiedFilter;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> Encoder(<span style="color:#ff79c6">comptime</span> Header<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">type</span>) <span style="color:#8be9fd">type</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> SBF <span style="color:#ff79c6">=</span> SimplifiedFilter(Header);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> Self <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@This</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        allocator<span style="color:#ff79c6">:</span> std.mem.Allocator,
</span></span><span style="display:flex;"><span>        filter<span style="color:#ff79c6">:</span> SBF,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> init(allocator<span style="color:#ff79c6">:</span> std.mem.Allocator, message_length<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>, fpr<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span>) <span style="color:#ff79c6">!</span>Self {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> n <span style="color:#ff79c6">=</span> message_length <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">8</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> byte_num <span style="color:#ff79c6">=</span> computeFilterSizeK1(n, fpr);
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">try</span> allowed_range(byte_num <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">8</span>, n);
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> .{
</span></span><span style="display:flex;"><span>                .allocator <span style="color:#ff79c6">=</span> allocator,
</span></span><span style="display:flex;"><span>                .filter <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">try</span> SBF.init(allocator, byte_num),
</span></span><span style="display:flex;"><span>            };
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> deinit(self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span>Self) <span style="color:#8be9fd">void</span> {
</span></span><span style="display:flex;"><span>            self.filter.deinit(self.allocator);
</span></span><span style="display:flex;"><span>            self.<span style="color:#ff79c6">*</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">undefined</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> encode(
</span></span><span style="display:flex;"><span>            self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span>Self,
</span></span><span style="display:flex;"><span>            nonce<span style="color:#ff79c6">:</span> Header,
</span></span><span style="display:flex;"><span>            input<span style="color:#ff79c6">:</span> []<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">u8</span>,
</span></span><span style="display:flex;"><span>            state_change<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">fn</span> (Header) Header,
</span></span><span style="display:flex;"><span>        ) Header {
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// reuse memory
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#8be9fd;font-style:italic">@memset</span>(self.filter.filter, <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">var</span> hdr<span style="color:#ff79c6">:</span> Header <span style="color:#ff79c6">=</span> nonce;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">for</span> (input) <span style="color:#ff79c6">|</span>byte<span style="color:#ff79c6">|</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">var</span> bit_shift<span style="color:#ff79c6">:</span> u3 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">7</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">while</span> (<span style="color:#ff79c6">true</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">const</span> bit<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">bool</span> <span style="color:#ff79c6">=</span> ((byte <span style="color:#ff79c6">&gt;&gt;</span> bit_shift) <span style="color:#ff79c6">&amp;</span> <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>                    hdr <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">if</span> (bit) state_change(hdr) <span style="color:#ff79c6">else</span> state_change(<span style="color:#ff79c6">~</span>hdr);
</span></span><span style="display:flex;"><span>                    self.filter.insert(hdr);
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">if</span> (bit_shift <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) <span style="color:#ff79c6">break</span>;
</span></span><span style="display:flex;"><span>                    bit_shift <span style="color:#ff79c6">-=</span> <span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> hdr;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> get_encoding(self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span>Self) []<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">u8</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> self.filter.filter;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">/// For the k=1 simplified filter:
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">///   p0 ‚âà 1 - exp(-n/m)  =&gt;  m ‚âà -n / ln(1 - p0)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">/// We return a byte count (rounded up).
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">fn</span> computeFilterSizeK1(n<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>, fpr<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span>) <span style="color:#8be9fd">usize</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> n_f<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@floatFromInt</span>(n);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> m_bits_f<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">-</span>n_f <span style="color:#ff79c6">/</span> <span style="color:#8be9fd;font-style:italic">@log</span>(<span style="color:#bd93f9">1.0</span> <span style="color:#ff79c6">-</span> fpr);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> m_bits<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@intFromFloat</span>(<span style="color:#8be9fd;font-style:italic">@ceil</span>(m_bits_f));
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> (m_bits <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">7</span>) <span style="color:#ff79c6">/</span> <span style="color:#bd93f9">8</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">fn</span> allowed_range(m_bits<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>, n<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>) <span style="color:#ff79c6">!</span><span style="color:#8be9fd">void</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> m_f <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@as</span>(<span style="color:#8be9fd">f64</span>, <span style="color:#8be9fd;font-style:italic">@floatFromInt</span>(m_bits));
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> n_f <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@as</span>(<span style="color:#8be9fd">f64</span>, <span style="color:#8be9fd;font-style:italic">@floatFromInt</span>(n));
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> ln2<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@log</span>(<span style="color:#8be9fd;font-style:italic">@as</span>(<span style="color:#8be9fd">f64</span>, <span style="color:#bd93f9">2.0</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> k_real<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span> <span style="color:#ff79c6">=</span> (m_f <span style="color:#ff79c6">/</span> n_f) <span style="color:#ff79c6">*</span> ln2;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> k_rounded<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@intFromFloat</span>(<span style="color:#8be9fd;font-style:italic">@round</span>(k_real));
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (k_rounded <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.InvalidFPR;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
  </div>
</div>

<h2 id="decoding-finding-the-correct-path">Decoding: finding the correct path <a href="#decoding-finding-the-correct-path" class="anchor">üîó</a></h2><p>To retrieve the original message, we iteratively reconstruct it from left to right. We start by checking the presence of the <em>first symbol</em> (bit) in the Bloom filter. Because each bit could be either <code>0</code> or <code>1</code>, we perform two lookups. Due to false positives, both might appear present. If so, we must keep <em>both</em> as potential candidates, one is right, one is wrong, but we don‚Äôt yet know which.</p>
<p>If only <code>1</code> appears present, then in the next iteration we perform lookups only for sequences continuing from that known prefix.  For example, if the first bit is confirmed as <code>1</code>, then we only check for chain headers corresponding to segments <code>10</code> and <code>11</code>, skipping <code>00</code> and <code>01</code>. If both <code>0</code> and <code>1</code> remain possible after the first iteration, we must explore four states in the next: <code>00</code>, <code>01</code>, <code>10</code>, and <code>11</code>. At first glance, this might seem to explode into $2^N$ lookups for an $N$-bit message, but it turns out the math is on our side.</p>
<h3 id="paths-trees-and-probabilities">Paths, trees, and probabilities <a href="#paths-trees-and-probabilities" class="anchor">üîó</a></h3><p>Let‚Äôs clarify some terminology. We call a candidate sequence that matches the true message the &ldquo;<strong>correct path</strong>&rdquo;. All other candidates are &ldquo;<strong>wrong paths</strong>&rdquo;. You can visualize the decoding process as an <em>expanding binary tree</em>, where the tree depth corresponds to the message length. We begin at the root (the initial chain header) and, at each step, check whether branch <code>0</code> or branch <code>1</code> exists in the Bloom filter. As we traverse, the tree grows. The original message, the correct path, corresponds to one specific route through this tree (see Figure 3). False positives cause additional branches to appear (Figure 4). The goal of decoding is to efficiently recover the correct path hidden among exponentially many candidates, a message buried in a haystack of false positives.</p>
<p align="center">
 <img width="100%" height="100%" src="/images/information_chaining_part_1/correct_path.svg">
 <em><br/>Figure 3. The message can be imagined as a path through the binary tree of the decoding process. This path is also referred to as the correct path. The goal of decoding is to iteratively recover the correct path.</em>
</p>
<p>If every lookup had the same probability of success, our attempt to decode the sequence would be futile, the number of wrong paths would quickly explode. But in Information Chaining, not all lookups are equal. The probability that a <em>correct-path segment</em> appears present is always 1, since it was actually inserted. For <em>wrong paths</em>, the first bit has probability $p$ (the Bloom filter‚Äôs false positive rate). At depth 2, that probability becomes $p^2$; at depth 3, $p^3$; and so on. Why? Because our lookups are no longer independent. The presence of each lookup depends on the previous ones. If $p = 0.1$, then the next level‚Äôs false positive rate becomes $0.01$. As long as $p &lt; 0.5$, wrong paths are pruned faster than they‚Äôre created. This prevents the exponential blowup and keeps the decoding process tractable. <strong>Voil√†, probabilistic Information Chaining!</strong></p>
<p align="center">
 <img width="100%" height="100%" src="/images/information_chaining_part_1/branching.svg">
 <em><br/>Figure 4. False positives cause branching during decoding. Because of the conditional structure of Information Chaining, wrong paths are pruned over time.</em>
</p>
<h3 id="why-the-false-positive-rate-matters">Why the false positive rate matters <a href="#why-the-false-positive-rate-matters" class="anchor">üîó</a></h3><p>In Information Chaining, each symbol‚Äôs mapping onto the Bloom filter depends on all <em>previous</em> symbols, transforming independent probabilities into conditional ones. But why must the false positive rate be below 0.5? The number of potential decoding paths depends directly on $p$. If $p = 0.5$, then at depth 16 the false positive probability for a symbol is $0.5^{16} = 0.0000152587890625$. That sounds small, but a binary tree of depth 16 has $2^{16} = 65,536$ paths, and $65,536 \times 0.0000152587890625 = 1$. In other words, the number of potential paths grows linearly with depth. Not ideal.</p>
<p>We want the expected number of paths multiplied by their probability to stay slightly below 1. That ensures decoding remains efficient without exponential growth. If $p$ is a bit smaller, say 0.48, something remarkable happens: the number of potential paths doesn‚Äôt grow linearly or even logarithmically, it converges to a fixed number. The expected number of paths is given by:</p>
<p>$$1 + \sum_{i=0}^{n} 2^{i} p^{i+1}$$</p>
<p>Let‚Äôs unpack this (see Figure 5). During decoding, the correct path and all of its subpaths are guaranteed to appear. Each symbol along that path can spawn a wrong branch with probability $p$. Breaking down the formula:</p>
<ul>
<li>The <strong>1</strong> represents the correct path.</li>
<li>The <strong>$2^i$</strong> term counts the number of leaf nodes in a branch (e.g., branch A has $2^0 = 1$, branch B has $2^1 = 2$, etc.).</li>
<li>The <strong>$p^{i+1}$</strong> term captures the probability that a wrong branch of depth $i + 1$ remains fully ‚Äúalive‚Äù (i.e., unpruned).</li>
</ul>
<p>The further a wrong path strays from the correct one, the less likely it is to survive. Early iterations may branch aggressively, but older ones quickly converge toward the single correct path. That&rsquo;s why the candidate paths in <em>Code Example 3</em> don&rsquo;t have to store the entire decoded message. to re-emphesize: wrong paths that split earlier from the correct path during decoding have a significantly smaller chance of &ldquo;survival&rdquo; with each new iteration compared to wrong paths that split up more recently from the correct path. Only the most recent symbols (bits) of the candidate paths differ. That&rsquo;s all the data that needs to be stored per candidate path.</p>
<p align="center">
 <img width="100%" height="100%" src="/images/information_chaining_part_1/expected_wrong_paths.svg">
 <em><br/>Figure 5. Wrong branches (A, B, C, D) at various depths. Each branch‚Äôs survival probability decreases exponentially with distance from the correct path.</em>
</p>
<div class="code-frame">
    <div class="code-frame__title">Code Example 3. Information Chaining Decoder Prototype</div>
  <div class="code-frame__body"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#ff79c6">const</span> std <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@import</span>(<span style="color:#f1fa8c">&#34;std&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">const</span> Allocator <span style="color:#ff79c6">=</span> std.mem.Allocator;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">const</span> SimplifiedFilter <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@import</span>(<span style="color:#f1fa8c">&#34;simplified_filter.zig&#34;</span>).SimplifiedFilter;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> decoder_prototype(
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">comptime</span> lineageType<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">type</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">comptime</span> headerType<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">type</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">comptime</span> message_length<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>, <span style="color:#6272a4">// in bytes
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>) <span style="color:#8be9fd">type</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> Self <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@This</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> SBF<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">type</span> <span style="color:#ff79c6">=</span> SimplifiedFilter(headerType);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> decode(
</span></span><span style="display:flex;"><span>            allocator<span style="color:#ff79c6">:</span> Allocator,
</span></span><span style="display:flex;"><span>            nonce<span style="color:#ff79c6">:</span> headerType,
</span></span><span style="display:flex;"><span>            final_chain_header<span style="color:#ff79c6">:</span> headerType,
</span></span><span style="display:flex;"><span>            sbf<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> SBF,
</span></span><span style="display:flex;"><span>            out<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span>[message_length]<span style="color:#8be9fd">u8</span>,
</span></span><span style="display:flex;"><span>            state_change<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">fn</span> (headerType) headerType,
</span></span><span style="display:flex;"><span>        ) <span style="color:#ff79c6">!</span><span style="color:#8be9fd">void</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> Paths <span style="color:#ff79c6">=</span> paths(lineageType, headerType);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> message_bits<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> message_length <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">8</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> L<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@bitSizeOf</span>(lineageType);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> prefix_bits<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> message_bits <span style="color:#ff79c6">-</span> L;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            out.<span style="color:#ff79c6">*</span> <span style="color:#ff79c6">=</span> [_]<span style="color:#8be9fd">u8</span>{<span style="color:#bd93f9">0</span>} <span style="color:#ff79c6">**</span> message_length;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">var</span> current <span style="color:#ff79c6">=</span> Paths.init(allocator);
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">defer</span> current.deinit();
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">var</span> next <span style="color:#ff79c6">=</span> Paths.init(allocator);
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">defer</span> next.deinit();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">try</span> current.addPath(nonce, <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// Warm-up: fill up the lineage register with the first L bits.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">for</span> (<span style="color:#bd93f9">0</span>..L) <span style="color:#ff79c6">|</span>_<span style="color:#ff79c6">|</span> {
</span></span><span style="display:flex;"><span>                next.paths.clearRetainingCapacity();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">for</span> (current.paths.items) <span style="color:#ff79c6">|</span>path<span style="color:#ff79c6">|</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">for</span> (<span style="color:#bd93f9">0</span>..<span style="color:#bd93f9">2</span>) <span style="color:#ff79c6">|</span>b_usize<span style="color:#ff79c6">|</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">const</span> bit <span style="color:#ff79c6">=</span> b_usize <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">const</span> header <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">if</span> (bit) state_change(path.header) <span style="color:#ff79c6">else</span> state_change(<span style="color:#ff79c6">~</span>path.header);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                        <span style="color:#6272a4">// Encoder inserted usize(hdr); mirror that here.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                        <span style="color:#ff79c6">if</span> (sbf.contains(header)) {
</span></span><span style="display:flex;"><span>                            <span style="color:#ff79c6">const</span> b<span style="color:#ff79c6">:</span> lineageType <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@as</span>(lineageType, <span style="color:#8be9fd;font-style:italic">@intCast</span>(b_usize));
</span></span><span style="display:flex;"><span>                            <span style="color:#ff79c6">const</span> lin<span style="color:#ff79c6">:</span> lineageType <span style="color:#ff79c6">=</span> (path.lineage <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">|</span> b;
</span></span><span style="display:flex;"><span>                            <span style="color:#ff79c6">try</span> next.addPath(header, lin);
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                std.mem.swap(Paths, <span style="color:#ff79c6">&amp;</span>current, <span style="color:#ff79c6">&amp;</span>next);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> (current.len() <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.NoCandidatePaths;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// Emit the first (message_bits - L) bits by repeatedly reading the MSB of lineage,
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#6272a4">// then advancing one step. This avoids stepping past the true end of the message.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">var</span> out_bit_index<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">while</span> (out_bit_index <span style="color:#ff79c6">&lt;</span> prefix_bits) <span style="color:#ff79c6">:</span> (out_bit_index <span style="color:#ff79c6">+=</span> <span style="color:#bd93f9">1</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> (current.len() <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.NoCandidatePaths;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">const</span> root_bit<span style="color:#ff79c6">:</span> u1 <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@truncate</span>(current.get(<span style="color:#bd93f9">0</span>).lineage <span style="color:#ff79c6">&gt;&gt;</span> (L <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// In debug/runtime-safety builds, ensure all candidates agree on the output bit.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#6272a4">// better heuristics can be used in practice (e.g. majority count, or reading only the first element while increasing linage size for better speed)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#ff79c6">if</span> (std.debug.runtime_safety) {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">for</span> (current.paths.items) <span style="color:#ff79c6">|</span>p<span style="color:#ff79c6">|</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">const</span> rb<span style="color:#ff79c6">:</span> u1 <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@truncate</span>(p.lineage <span style="color:#ff79c6">&gt;&gt;</span> (L <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>));
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">if</span> (rb <span style="color:#ff79c6">!=</span> root_bit) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.AmbiguousOutputBit;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                writeBit(message_length, out, out_bit_index, root_bit);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// Advance one step.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                next.paths.clearRetainingCapacity();
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">for</span> (current.paths.items) <span style="color:#ff79c6">|</span>path<span style="color:#ff79c6">|</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">for</span> (<span style="color:#bd93f9">0</span>..<span style="color:#bd93f9">2</span>) <span style="color:#ff79c6">|</span>b_usize<span style="color:#ff79c6">|</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">const</span> bit <span style="color:#ff79c6">=</span> b_usize <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">const</span> header <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">if</span> (bit) state_change(path.header) <span style="color:#ff79c6">else</span> state_change(<span style="color:#ff79c6">~</span>path.header);
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">if</span> (sbf.contains(header)) {
</span></span><span style="display:flex;"><span>                            <span style="color:#ff79c6">const</span> b<span style="color:#ff79c6">:</span> lineageType <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@as</span>(lineageType, <span style="color:#8be9fd;font-style:italic">@intCast</span>(b_usize));
</span></span><span style="display:flex;"><span>                            <span style="color:#ff79c6">const</span> lin<span style="color:#ff79c6">:</span> lineageType <span style="color:#ff79c6">=</span> (path.lineage <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">|</span> b;
</span></span><span style="display:flex;"><span>                            <span style="color:#ff79c6">try</span> next.addPath(header, lin);
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                std.mem.swap(Paths, <span style="color:#ff79c6">&amp;</span>current, <span style="color:#ff79c6">&amp;</span>next);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// At this point we&#39;ve advanced exactly message_bits steps total (L warm-up + prefix_bits).
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#6272a4">// So we&#39;re at the true end of the message. Find the path with the correct final header,
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#6272a4">// and append the remaining L bits that are still sitting inside its lineage.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">const</span> shiftType <span style="color:#ff79c6">=</span> getLog2Type(lineageType);
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">for</span> (current.paths.items) <span style="color:#ff79c6">|</span>path<span style="color:#ff79c6">|</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> (path.header <span style="color:#ff79c6">==</span> final_chain_header) {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">for</span> (<span style="color:#bd93f9">0</span>..L) <span style="color:#ff79c6">|</span>i<span style="color:#ff79c6">|</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">const</span> shift<span style="color:#ff79c6">:</span> shiftType <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@truncate</span>((L <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">-</span> i);
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">const</span> bit<span style="color:#ff79c6">:</span> u1 <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@truncate</span>(path.lineage <span style="color:#ff79c6">&gt;&gt;</span> shift);
</span></span><span style="display:flex;"><span>                        writeBit(message_length, out, prefix_bits <span style="color:#ff79c6">+</span> i, bit);
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">return</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.PathNotFound;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> paths(<span style="color:#ff79c6">comptime</span> lineageType<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">type</span>, <span style="color:#ff79c6">comptime</span> headerType<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">type</span>) <span style="color:#8be9fd">type</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> Path <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">struct</span> { header<span style="color:#ff79c6">:</span> headerType, lineage<span style="color:#ff79c6">:</span> lineageType };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> Self <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@This</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        allocator<span style="color:#ff79c6">:</span> Allocator,
</span></span><span style="display:flex;"><span>        paths<span style="color:#ff79c6">:</span> std.ArrayList(Path) <span style="color:#ff79c6">=</span> .empty,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> init(allocator<span style="color:#ff79c6">:</span> Allocator) Self {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> .{ .allocator <span style="color:#ff79c6">=</span> allocator, .paths <span style="color:#ff79c6">=</span> .empty };
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> deinit(self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span>Self) <span style="color:#8be9fd">void</span> {
</span></span><span style="display:flex;"><span>            self.paths.deinit(self.allocator);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> addPath(self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span>Self, h<span style="color:#ff79c6">:</span> headerType, l<span style="color:#ff79c6">:</span> lineageType) <span style="color:#ff79c6">!</span><span style="color:#8be9fd">void</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">try</span> self.paths.append(self.allocator, .{ .header <span style="color:#ff79c6">=</span> h, .lineage <span style="color:#ff79c6">=</span> l });
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> len(self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> Self) <span style="color:#8be9fd">usize</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> self.paths.items.len;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> get(self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> Self, i<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>) <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> Path {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>self.paths.items[i];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">fn</span> writeBit(
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">comptime</span> message_length<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>    out<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span>[message_length]<span style="color:#8be9fd">u8</span>,
</span></span><span style="display:flex;"><span>    bit_index<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>, <span style="color:#6272a4">// 0..message_length*8
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    bit<span style="color:#ff79c6">:</span> u1,
</span></span><span style="display:flex;"><span>) <span style="color:#8be9fd">void</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> byte_index<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> bit_index <span style="color:#ff79c6">/</span> <span style="color:#bd93f9">8</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> bit_in_byte<span style="color:#ff79c6">:</span> u3 <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@intCast</span>(<span style="color:#bd93f9">7</span> <span style="color:#ff79c6">-</span> (bit_index <span style="color:#ff79c6">%</span> <span style="color:#bd93f9">8</span>)); <span style="color:#6272a4">// msb-first
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">const</span> mask<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">u8</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@as</span>(<span style="color:#8be9fd">u8</span>, <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">&lt;&lt;</span> bit_in_byte;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (bit <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1</span>) out[byte_index] <span style="color:#ff79c6">|=</span> mask;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">inline</span> <span style="color:#ff79c6">fn</span> getLog2Type(<span style="color:#ff79c6">comptime</span> T<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">type</span>) <span style="color:#8be9fd">type</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">comptime</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> (<span style="color:#8be9fd;font-style:italic">@typeInfo</span>(T).int.signedness <span style="color:#ff79c6">!=</span> .unsigned) <span style="color:#8be9fd;font-style:italic">@compileError</span>(<span style="color:#f1fa8c">&#34;getLog2Type: T must be an unsigned integer type&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> bits <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@typeInfo</span>(T).int.bits;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> (bits <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">or</span> (bits <span style="color:#ff79c6">&amp;</span> (bits <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>)) <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">0</span>) <span style="color:#8be9fd;font-style:italic">@compileError</span>(<span style="color:#f1fa8c">&#34;getLog2Type: bit-width must be a power of two&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> log2_bits <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@log2</span>(<span style="color:#8be9fd;font-style:italic">@as</span>(<span style="color:#8be9fd">f16</span>, bits));
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">@Type</span>(.{
</span></span><span style="display:flex;"><span>            .int <span style="color:#ff79c6">=</span> .{
</span></span><span style="display:flex;"><span>                .signedness <span style="color:#ff79c6">=</span> .unsigned,
</span></span><span style="display:flex;"><span>                .bits <span style="color:#ff79c6">=</span> log2_bits,
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
  </div>
</div>

<p>Figure 6 shows how the false positive rate affects the expected number of decoding paths for a one-million-bit message. As $p$ decreases, the expected number of paths, and thus the decoding effort, drops sharply. Fewer paths mean faster decoding. You might wonder: why not simply choose a very small $p$, like 0.01, and enjoy near-instant decoding? Because reducing $p$ also increases the Bloom filter‚Äôs size. Figure 7 illustrates this trade-off. Lowering $p$ reduces time overhead but increases space overhead. The ideal balance between the two depends on the application.</p>
<p align="center">
 <img width="100%" height="100%" src="/images/information_chaining_part_1/fpr_to_paths.svg">
 <em><br/>Figure 6. Relationship between false positive rate and expected number of potential paths during decoding.</em>
</p>
<p align="center">
 <img width="100%" height="100%" src="/images/information_chaining_part_1/fpr_to_bf_m.svg">
 <em><br/>Figure 7. Bloom filter size as a function of false positive rate.</em>
</p>
<h1 id="from-chaining-to-erasure-coding">From Chaining to Erasure Coding <a href="#from-chaining-to-erasure-coding" class="anchor">üîó</a></h1><p><strong>If you&rsquo;ve come this far, it&rsquo;s time to finally talk about the why.</strong></p>
<p>Imagine you‚Äôre a sender who needs to reliably transmit a series of data packets to a receiver over the Internet. What‚Äôs the fastest and most reliable way to do it? The most na√Øve method would be a connectionless approach (e.g., using UDP), transmitting the entire message multiple times. Even if some packets are lost, the receiver could reconstruct the message from redundant copies. While this <em>works</em>, it‚Äôs terribly inefficient, the bandwidth overhead is enormous.</p>
<p>We want high reliability without excessive redundancy. A connection-oriented protocol like TCP seems like the next logical choice: the sender retransmits only the packets that weren‚Äôt acknowledged. This improves bandwidth efficiency, but at the cost of <em>latency</em>, every lost packet requires a round-trip before recovery. For many time-sensitive systems, that back-and-forth simply isn‚Äôt acceptable. In some applications, it‚Äôs better to drop packets than to stall. But what if reliability <em>is</em> essential? Can we transmit data with high reliability and low latency, avoiding retransmissions altogether?</p>
<h2 id="the-promise-of-erasure-codes">The promise of erasure codes <a href="#the-promise-of-erasure-codes" class="anchor">üîó</a></h2><p>If we can estimate the percentage of packets likely to be lost during transmission, say, due to noise, congestion, or interference we can use <strong>erasure coding</strong> for reliable, one-way transmission. In coding theory, an erasure code is a type of <em>forward error correction</em> (FEC) code. FEC schemes allow the receiver to detect and correct errors, or, in the case of erasures, to reconstruct missing data, without requiring retransmission. This property is invaluable for storing data across unreliable networks or transmitting it through noisy channels. For example, if a sender transmits several data packets to a receiver, the goal of an erasure code is to enable the receiver to reconstruct the original message even if some packets are lost in transit (i.e., &ldquo;erased&rdquo;).</p>
<p>Erasure codes work by transforming an original message of $n$ symbols into a longer message of $z$ symbols. The $n$ original symbols are called <em>source symbols</em>, while the additional ones are <em>encoded symbols</em>. Even if some encoded symbols are lost, the receiver can reconstruct the original message using a subset of the $z$ encoded symbols. The number of encoded symbols required to recover the original message depends on the erasure code&rsquo;s <em>code rate</em>, defined as $\frac{n}{z}$. Or in other words, it represents the portion of the data that is not redundant. For every $n$ source symbols, $z$ encoded symbols are created, $z-n$ of which are redundant. An <em>optimal erasure code</em> allows full reconstruction from any $n$ of the $z$ encoded symbols.</p>
<h2 id="designing-a-bloom-filterbased-erasure-encoder">Designing a Bloom filter‚Äìbased erasure encoder <a href="#designing-a-bloom-filterbased-erasure-encoder" class="anchor">üîó</a></h2><p>Now imagine applying this logic to network packets. If we could transform $n$ packets into $z$ packets (where $z &gt; n$) and transmit them using a connectionless protocol, the receiver could reconstruct the original data from any subset of those $z$ packets, even if some were lost along the way. Here‚Äôs where Information Chaining re-enters the picture. Our Bloom filter‚Äìbased prototype can be adapted into an erasure code in multiple ways:</p>
<ul>
<li>Use many small Bloom filters (with higher false positive rates) and compress them, for instance, using <a href="https://web.archive.org/web/20220620080435/https://giovanni.bajo.it/post/47119962313/golomb-coded-sets-smaller-than-bloom-filters" target="_blank" rel="noopener">Golomb Coded Sets</a>. Or</li>
<li>Use a single large Bloom filter and later packetize it.</li>
</ul>
<p>To keep things simple, let‚Äôs explore the second option.</p>
<p>Suppose we expect 10% packet loss during transmission. That means our <em>loss rate</em> $l$ is $0.1$. We take our input message of $n$ bits, encode it into a single large filter of $m$ bits, split that filter into packets, and ship them out. The receiver reconstructs the filter from whatever packets arrive. Any missing packet region is treated as ‚Äúunknown‚Äù and is set to 1 in the filter. That last choice is the entire crux. Packet loss increases the probability that a lookup lands in a region that we blindly declare present. In this section, we‚Äôll derive the correct sizing formula under one explicit assumption:</p>
<blockquote>
<p><strong>Assumption:</strong> we are using the Part 1 <em>simplified</em> filter variant with <strong>$k = 1$</strong>, meaning each insertion sets exactly one bit.</p>
</blockquote>
<p>With $k = 1$, each inserted element maps to one bit position. Because of collisions, inserting $n$ elements does not set $n$ distinct bit positions. The question becomes: after $n$ random insertions into $m$ bits, what fraction of bits are expected to be 1? Pick a specific bit in the filter. The probability that a single insertion does not hit it is:
$\left(1 - \frac{1}{m}\right)$. So the probability that none of the $n$ insertions hit it is: $\left(1-\frac{1}{m}\right)^n$. Therefore, the probability that this bit ends up being 1 (i.e., it got hit at least once) is: $p_0 = 1 - \left(1-\frac{1}{m}\right)^n$. For our $k=1$ filter, this is also the <em>baseline false positive rate</em>. For large $m$, we use the classic approximation:
$$
\left(1-\frac{1}{m}\right)^n \approx e^{\frac{-n}{m}}
\quad\Rightarrow\quad
p_0 \approx 1 - e^{\frac{-n}{m}}
$$</p>
<p>If packets are all the same size, then losing a fraction $l$ of packets means losing roughly a fraction $l$ of the filter‚Äôs bits. Recall, in this implementation, lost bits are set to 1. So for a wrong-path lookup (a non-member query), there are two cases:</p>
<ul>
<li>With probability $l$, the lookup lands in a missing region, where the bit is forced to 1, which returns a positive match. It can be a true positive, but it also might be a false positive.</li>
<li>With probability $1-l$, the lookup lands in a received region, where the baseline false positive rate is $p_0$.</li>
</ul>
<p>So the <em>effective</em> false positive rate seen by the decoder is: $\left(p_{\text{eff}} = l + (1-l)p_0\right)$. This equation is the bridge between <em>packet loss</em> and <em>decoder branching</em>. Loss shows up exactly where it hurts: in the probability that the decoder is forced to say ‚Äúmaybe‚Äù. In the rest of this post, the false positive rate $p$ is what governs branching behavior during decoding. In the erasure setting, that ‚Äú$p$‚Äù should really be $p_{\text{eff}}$, the rate after erasures have done their damage.</p>
<p>So we pick a target $p_{\text{eff}}$ (for example, $0.48$ to keep branching under control), and we solve for the baseline rate we must achieve <em>before</em> packet loss: $\left(p_0 = \frac{p_{\text{eff}} - l}{1-l}\right)$. Now we plug $p_0$ into the collision/occupancy equation: $\left(1 - \left(1-\frac{1}{m}\right)^n = \frac{p_{\text{eff}} - l}{1-l}\right)$. After rearrangement: $\left(\left(1-\frac{1}{m}\right)^n = \frac{1 - p_{\text{eff}}}{1-l}\right)$. Then we take the $n$th root and get: $\left(1-\frac{1}{m} = \left(\frac{1 - p_{\text{eff}}}{1-l}\right)^{\frac{1}{n}}\right)$. And finally we solve for $m$:</p>
<p>$$
m = \frac{1}{1 - \left(\frac{1 - p_{\text{eff}}}{1-l}\right)^{\frac{1}{n}}}
$$</p>
<p>That‚Äôs the exact, collision-aware sizing rule for the $k=1$ erasure encoder. For large $n$ (and this is typically the regime we care about), we can use the exponential approximation and get a much nicer closed form:</p>
<p>$$
m \approx -\frac{n}{\ln\left(\frac{1 - p_{\text{eff}}}{1-l}\right)}
$$</p>
<p>In simpler terms, <em>Code Example 4</em> takes as input the message length $n$ (in bits), the expected packet loss rate $l$, the target effective false positive rate $p_{\text{eff}}$ (e.g., $0.48$), and the packet payload size in bytes. the function then Computes $m$ using the formula above (exact or approximate), round $m$ up to a byte boundary, then round again to a whole number of packets, and finally run the same chained insertion loop as in <em>Code Example 2</em> (we still insert exactly $n$ chain headers), and then packetize the resulting bit array. That‚Äôs it. Erasure are automatically accounted for by the filter expansion (larger $m$).</p>
<div class="code-frame">
    <div class="code-frame__title">Code Example 4. Bloom Filter Erasure Encoder</div>
  <div class="code-frame__body"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#ff79c6">const</span> std <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@import</span>(<span style="color:#f1fa8c">&#34;std&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">const</span> SimplifiedFilter <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@import</span>(<span style="color:#f1fa8c">&#34;simplified_filter.zig&#34;</span>).SimplifiedFilter;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">/// Erasure encoder built on top of the runtime-sized SimplifiedFilter and the Encoder prototype logic.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">///
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">/// - Sizes the filter for a target **effective** false positive rate `p_eff` after a packet loss rate `loss_rate`.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">/// - Rounds the filter size up to a whole number of packets.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">/// - Encodes the message using Information Chaining (same bit-walk as Code Example 2).
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">/// - Exposes the encoded filter as packet payloads (zero-copy views).
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> ErasureEncoder(<span style="color:#ff79c6">comptime</span> Header<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">type</span>) <span style="color:#8be9fd">type</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> SBF <span style="color:#ff79c6">=</span> SimplifiedFilter(Header);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> Self <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@This</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        allocator<span style="color:#ff79c6">:</span> std.mem.Allocator,
</span></span><span style="display:flex;"><span>        filter<span style="color:#ff79c6">:</span> SBF,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        message_length<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>, <span style="color:#6272a4">// bytes
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        packet_payload_bytes<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">const</span> Packet <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">struct</span> {
</span></span><span style="display:flex;"><span>            index<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>            payload<span style="color:#ff79c6">:</span> []<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">u8</span>,
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> init(
</span></span><span style="display:flex;"><span>            allocator<span style="color:#ff79c6">:</span> std.mem.Allocator,
</span></span><span style="display:flex;"><span>            message_length<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>            loss_rate<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span>,
</span></span><span style="display:flex;"><span>            p_eff<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span>,
</span></span><span style="display:flex;"><span>            packet_payload_bytes<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>        ) <span style="color:#ff79c6">!</span>Self {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> (message_length <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.InvalidMessageLength;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> (packet_payload_bytes <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.InvalidPacketPayload;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> n_bits<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> message_length <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">8</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 1) Compute the filter size in bytes using the erasure-aware sizing rule.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">var</span> byte_num<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">try</span> computeFilterSizeK1WithLoss(n_bits, loss_rate, p_eff);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 2) Round up to an integer number of packets.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            byte_num <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">try</span> roundUp(byte_num, packet_payload_bytes);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 3) Keep k = 1 in this simplified variant.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">try</span> allowed_range(byte_num <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">8</span>, n_bits);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> .{
</span></span><span style="display:flex;"><span>                .allocator <span style="color:#ff79c6">=</span> allocator,
</span></span><span style="display:flex;"><span>                .filter <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">try</span> SBF.init(allocator, byte_num),
</span></span><span style="display:flex;"><span>                .message_length <span style="color:#ff79c6">=</span> message_length,
</span></span><span style="display:flex;"><span>                .packet_payload_bytes <span style="color:#ff79c6">=</span> packet_payload_bytes,
</span></span><span style="display:flex;"><span>            };
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> deinit(self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span>Self) <span style="color:#8be9fd">void</span> {
</span></span><span style="display:flex;"><span>            self.filter.deinit(self.allocator);
</span></span><span style="display:flex;"><span>            self.<span style="color:#ff79c6">*</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">undefined</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">/// Encode `input` into the underlying filter.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">/// Returns the final chain header.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> encode(
</span></span><span style="display:flex;"><span>            self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span>Self,
</span></span><span style="display:flex;"><span>            nonce<span style="color:#ff79c6">:</span> Header,
</span></span><span style="display:flex;"><span>            input<span style="color:#ff79c6">:</span> []<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">u8</span>,
</span></span><span style="display:flex;"><span>            state_change<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">fn</span> (Header) Header,
</span></span><span style="display:flex;"><span>        ) Header {
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// For this prototype, require the encoder was sized for this message length.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            std.debug.assert(input.len <span style="color:#ff79c6">==</span> self.message_length);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// reuse memory
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#8be9fd;font-style:italic">@memset</span>(self.filter.filter, <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">var</span> hdr<span style="color:#ff79c6">:</span> Header <span style="color:#ff79c6">=</span> nonce;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">for</span> (input) <span style="color:#ff79c6">|</span>byte<span style="color:#ff79c6">|</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">var</span> bit_shift<span style="color:#ff79c6">:</span> u3 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">7</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">while</span> (<span style="color:#ff79c6">true</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">const</span> bit<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">bool</span> <span style="color:#ff79c6">=</span> ((byte <span style="color:#ff79c6">&gt;&gt;</span> bit_shift) <span style="color:#ff79c6">&amp;</span> <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>                    hdr <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">if</span> (bit) state_change(hdr) <span style="color:#ff79c6">else</span> state_change(<span style="color:#ff79c6">~</span>hdr);
</span></span><span style="display:flex;"><span>                    self.filter.insert(hdr);
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">if</span> (bit_shift <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) <span style="color:#ff79c6">break</span>;
</span></span><span style="display:flex;"><span>                    bit_shift <span style="color:#ff79c6">-=</span> <span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> hdr;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">/// Raw encoded filter bytes.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> get_encoding(self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> Self) []<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">u8</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> self.filter.filter;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> packet_count(self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> Self) <span style="color:#8be9fd">usize</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// filter size is always rounded to a multiple of packet_payload_bytes.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">return</span> self.filter.filter.len <span style="color:#ff79c6">/</span> self.packet_payload_bytes;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">/// Get a zero-copy view of packet `index`.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> packet(self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> Self, index<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>) Packet {
</span></span><span style="display:flex;"><span>            std.debug.assert(index <span style="color:#ff79c6">&lt;</span> self.packet_count());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> start<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> index <span style="color:#ff79c6">*</span> self.packet_payload_bytes;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> end<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> start <span style="color:#ff79c6">+</span> self.packet_payload_bytes;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> .{
</span></span><span style="display:flex;"><span>                .index <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@intCast</span>(index),
</span></span><span style="display:flex;"><span>                .payload <span style="color:#ff79c6">=</span> self.filter.filter[start..end],
</span></span><span style="display:flex;"><span>            };
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">fn</span> roundUp(x<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>, multiple<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>) <span style="color:#ff79c6">!</span><span style="color:#8be9fd">usize</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (multiple <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.InvalidPacketPayload;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> ((x <span style="color:#ff79c6">+</span> multiple <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">/</span> multiple) <span style="color:#ff79c6">*</span> multiple;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">/// Computes the filter size in **bytes** (rounded up) for the k=1 simplified filter,
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">/// while accounting for a packet loss rate `loss_rate`.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">fn</span> computeFilterSizeK1WithLoss(n_bits<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>, loss_rate<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span>, p_eff<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span>) <span style="color:#ff79c6">!</span><span style="color:#8be9fd">usize</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (n_bits <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.InvalidMessageLength;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>(loss_rate <span style="color:#ff79c6">&gt;=</span> <span style="color:#bd93f9">0.0</span> <span style="color:#ff79c6">and</span> loss_rate <span style="color:#ff79c6">&lt;</span> <span style="color:#bd93f9">1.0</span>)) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.InvalidLossRate;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>(p_eff <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">0.0</span> <span style="color:#ff79c6">and</span> p_eff <span style="color:#ff79c6">&lt;</span> <span style="color:#bd93f9">0.5</span>)) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.InvalidFPR;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>(p_eff <span style="color:#ff79c6">&gt;</span> loss_rate)) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.ImpossibleParameters;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> n_f<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@floatFromInt</span>(n_bits);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> ratio<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span> <span style="color:#ff79c6">=</span> (<span style="color:#bd93f9">1.0</span> <span style="color:#ff79c6">-</span> p_eff) <span style="color:#ff79c6">/</span> (<span style="color:#bd93f9">1.0</span> <span style="color:#ff79c6">-</span> loss_rate);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> root<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@exp</span>(<span style="color:#8be9fd;font-style:italic">@log</span>(ratio) <span style="color:#ff79c6">/</span> n_f);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> denom<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span> <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1.0</span> <span style="color:#ff79c6">-</span> root;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>(denom <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">0.0</span>)) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.ImpossibleParameters;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> m_bits_f<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span> <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1.0</span> <span style="color:#ff79c6">/</span> denom;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> m_bits<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@intFromFloat</span>(<span style="color:#8be9fd;font-style:italic">@ceil</span>(m_bits_f));
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> (m_bits <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">7</span>) <span style="color:#ff79c6">/</span> <span style="color:#bd93f9">8</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">fn</span> allowed_range(m_bits<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>, n_bits<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>) <span style="color:#ff79c6">!</span><span style="color:#8be9fd">void</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (m_bits <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">or</span> n_bits <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.InvalidMessageLength;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> m_f <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@as</span>(<span style="color:#8be9fd">f64</span>, <span style="color:#8be9fd;font-style:italic">@floatFromInt</span>(m_bits));
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> n_f <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@as</span>(<span style="color:#8be9fd">f64</span>, <span style="color:#8be9fd;font-style:italic">@floatFromInt</span>(n_bits));
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> ln2<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@log</span>(<span style="color:#8be9fd;font-style:italic">@as</span>(<span style="color:#8be9fd">f64</span>, <span style="color:#bd93f9">2.0</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> k_real<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span> <span style="color:#ff79c6">=</span> (m_f <span style="color:#ff79c6">/</span> n_f) <span style="color:#ff79c6">*</span> ln2;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> k_rounded<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@intFromFloat</span>(<span style="color:#8be9fd;font-style:italic">@round</span>(k_real));
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (k_rounded <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.InvalidFPR;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
  </div>
</div>

<h2 id="decoding-with-erasures">Decoding with erasures <a href="#decoding-with-erasures" class="anchor">üîó</a></h2><p>Once the receiver collects the packets, it reconstructs the original Bloom filter from the chunks. Any regions corresponding to missing packets are treated as ‚Äúunknown‚Äù and are set to <code>1</code>s. A lookup that lands in a missing region becomes therefore an unconditional match. During decoding, this means that whenever we reach a missing portion of the filter, we must treat <em>both</em> continuations as viable candidates, effectively branching off from every path currently stored in memory (see Figure 8). As long as the actual packet loss rate stays at or below the target loss rate used during encoding, the decoder can still recover the original message. And just like that, we‚Äôve created a <strong>Bloom filter‚Äìbased erasure code</strong>!</p>
<p align="center">
 <img width="100%" height="100%" src="/images/information_chaining_part_1/decoding_with_erasures.svg">
 <em><br/>Figure 8. Decoding with missing packets causes branch-offs, enabling recovery despite erasures.</em>
</p>
<p>For the hands-on reader, <em>Code Example 5</em> shows the corresponding decoder implementation. Feel free to experiment with different loss rates and false positive parameters to internalize the dynamics. Decreasing the target false positive rate for a fixed loss rate reduces the decoder‚Äôs memory footprint (fewer branches survive), but increases bandwidth (the code overhead grows). As the target false positive rate approaches $0.5$, the overhead drops, but the number of potential paths rapidly increases.</p>
<div class="code-frame">
    <div class="code-frame__title">Code Example 5. Bloom Filter Erasure Decoder</div>
  <div class="code-frame__body"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#ff79c6">const</span> std <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@import</span>(<span style="color:#f1fa8c">&#34;std&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">const</span> SimplifiedFilter <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@import</span>(<span style="color:#f1fa8c">&#34;simplified_filter.zig&#34;</span>).SimplifiedFilter;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">/// Packetized erasure decoder.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">///
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">/// Usage model:
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">/// - Both sides agree on (message_length, loss_rate, p_eff, packet_payload_bytes).
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">/// - Receiver collects any subset of packets (each includes an index).
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">/// - Receiver reconstructs the filter by setting missing packet regions to all 1s (0xFF).
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">/// - Then runs the standard Information Chaining decoder on the reconstructed filter.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> ErasureDecoder(<span style="color:#ff79c6">comptime</span> Lineage<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">type</span>, <span style="color:#ff79c6">comptime</span> Header<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">type</span>) <span style="color:#8be9fd">type</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> SBF <span style="color:#ff79c6">=</span> SimplifiedFilter(Header);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> Self <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@This</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        allocator<span style="color:#ff79c6">:</span> std.mem.Allocator,
</span></span><span style="display:flex;"><span>        filter<span style="color:#ff79c6">:</span> SBF,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        message_length<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>        packet_payload_bytes<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>        packet_count<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">const</span> Packet <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">struct</span> {
</span></span><span style="display:flex;"><span>            index<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">u32</span>,
</span></span><span style="display:flex;"><span>            payload<span style="color:#ff79c6">:</span> []<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">u8</span>,
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> init(
</span></span><span style="display:flex;"><span>            allocator<span style="color:#ff79c6">:</span> std.mem.Allocator,
</span></span><span style="display:flex;"><span>            message_length<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>            loss_rate<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span>,
</span></span><span style="display:flex;"><span>            p_eff<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span>,
</span></span><span style="display:flex;"><span>            packet_payload_bytes<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>,
</span></span><span style="display:flex;"><span>        ) <span style="color:#ff79c6">!</span>Self {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> (message_length <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.InvalidMessageLength;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> (packet_payload_bytes <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.InvalidPacketPayload;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> n_bits<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> message_length <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">8</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">var</span> byte_num<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">try</span> computeFilterSizeK1WithLoss(n_bits, loss_rate, p_eff);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// Must match the encoder&#39;s rounding to whole packets.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            byte_num <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">try</span> roundUp(byte_num, packet_payload_bytes);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> pkt_count<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> byte_num <span style="color:#ff79c6">/</span> packet_payload_bytes;
</span></span><span style="display:flex;"><span>            std.debug.assert(byte_num <span style="color:#ff79c6">%</span> packet_payload_bytes <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> .{
</span></span><span style="display:flex;"><span>                .allocator <span style="color:#ff79c6">=</span> allocator,
</span></span><span style="display:flex;"><span>                .filter <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">try</span> SBF.init(allocator, byte_num),
</span></span><span style="display:flex;"><span>                .message_length <span style="color:#ff79c6">=</span> message_length,
</span></span><span style="display:flex;"><span>                .packet_payload_bytes <span style="color:#ff79c6">=</span> packet_payload_bytes,
</span></span><span style="display:flex;"><span>                .packet_count <span style="color:#ff79c6">=</span> pkt_count,
</span></span><span style="display:flex;"><span>            };
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> deinit(self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span>Self) <span style="color:#8be9fd">void</span> {
</span></span><span style="display:flex;"><span>            self.filter.deinit(self.allocator);
</span></span><span style="display:flex;"><span>            self.<span style="color:#ff79c6">*</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">undefined</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> expected_packet_count(self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> Self) <span style="color:#8be9fd">usize</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> self.packet_count;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">/// Reconstruct the underlying filter from received packets.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">///
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">/// Any packet index that isn&#39;t present in `packets` remains all 1s (0xFF).
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> reconstruct_filter(self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span>Self, packets<span style="color:#ff79c6">:</span> []<span style="color:#ff79c6">const</span> Packet) <span style="color:#ff79c6">!</span><span style="color:#8be9fd">void</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// Start with everything missing.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#8be9fd;font-style:italic">@memset</span>(self.filter.filter, <span style="color:#bd93f9">0xFF</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">for</span> (packets) <span style="color:#ff79c6">|</span>pkt<span style="color:#ff79c6">|</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">const</span> idx<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@intCast</span>(pkt.index);
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> (idx <span style="color:#ff79c6">&gt;=</span> self.packet_count) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.PacketIndexOutOfRange;
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> (pkt.payload.len <span style="color:#ff79c6">!=</span> self.packet_payload_bytes) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.BadPacketSize;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">const</span> start<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> idx <span style="color:#ff79c6">*</span> self.packet_payload_bytes;
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">const</span> end<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> start <span style="color:#ff79c6">+</span> self.packet_payload_bytes;
</span></span><span style="display:flex;"><span>                std.mem.copyForwards(<span style="color:#8be9fd">u8</span>, self.filter.filter[start..end], pkt.payload);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">/// Decode the original message from a set of received packets.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">///
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">/// `out` must be a buffer of length `message_length`.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> decode(
</span></span><span style="display:flex;"><span>            self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span>Self,
</span></span><span style="display:flex;"><span>            nonce<span style="color:#ff79c6">:</span> Header,
</span></span><span style="display:flex;"><span>            final_chain_header<span style="color:#ff79c6">:</span> Header,
</span></span><span style="display:flex;"><span>            packets<span style="color:#ff79c6">:</span> []<span style="color:#ff79c6">const</span> Packet,
</span></span><span style="display:flex;"><span>            out<span style="color:#ff79c6">:</span> []<span style="color:#8be9fd">u8</span>,
</span></span><span style="display:flex;"><span>            state_change<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">fn</span> (Header) Header,
</span></span><span style="display:flex;"><span>        ) <span style="color:#ff79c6">!</span><span style="color:#8be9fd">void</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> (out.len <span style="color:#ff79c6">!=</span> self.message_length) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.BadOutputSize;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// Rebuild filter bytes (missing -&gt; 0xFF) and run the normal decoder.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">try</span> self.reconstruct_filter(packets);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> message_bits<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> self.message_length <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">8</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> L<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@bitSizeOf</span>(Lineage);
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> (L <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.InvalidLineage;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> (L <span style="color:#ff79c6">&gt;</span> message_bits) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.LineageTooLarge;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> prefix_bits<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> message_bits <span style="color:#ff79c6">-</span> L;
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">@memset</span>(out, <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">const</span> Paths <span style="color:#ff79c6">=</span> paths(Lineage, Header);
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">var</span> current <span style="color:#ff79c6">=</span> Paths.init(self.allocator);
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">defer</span> current.deinit();
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">var</span> next <span style="color:#ff79c6">=</span> Paths.init(self.allocator);
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">defer</span> next.deinit();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">try</span> current.addPath(nonce, <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// Warm-up: fill lineage with the first L bits.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">for</span> (<span style="color:#bd93f9">0</span>..L) <span style="color:#ff79c6">|</span>_<span style="color:#ff79c6">|</span> {
</span></span><span style="display:flex;"><span>                next.clearRetainingCapacity();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">for</span> (current.paths.items) <span style="color:#ff79c6">|</span>path<span style="color:#ff79c6">|</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">for</span> (<span style="color:#bd93f9">0</span>..<span style="color:#bd93f9">2</span>) <span style="color:#ff79c6">|</span>b_usize<span style="color:#ff79c6">|</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">const</span> bit_is_one <span style="color:#ff79c6">=</span> b_usize <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">const</span> header <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">if</span> (bit_is_one) state_change(path.header) <span style="color:#ff79c6">else</span> state_change(<span style="color:#ff79c6">~</span>path.header);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">if</span> (self.filter.contains(header)) {
</span></span><span style="display:flex;"><span>                            <span style="color:#ff79c6">const</span> b<span style="color:#ff79c6">:</span> Lineage <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@as</span>(Lineage, <span style="color:#8be9fd;font-style:italic">@intCast</span>(b_usize));
</span></span><span style="display:flex;"><span>                            <span style="color:#ff79c6">const</span> lin<span style="color:#ff79c6">:</span> Lineage <span style="color:#ff79c6">=</span> (path.lineage <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">|</span> b;
</span></span><span style="display:flex;"><span>                            <span style="color:#ff79c6">try</span> next.addPath(header, lin);
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                std.mem.swap(<span style="color:#8be9fd;font-style:italic">@TypeOf</span>(current), <span style="color:#ff79c6">&amp;</span>current, <span style="color:#ff79c6">&amp;</span>next);
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> (current.len() <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.NoCandidatePaths;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// Emit prefix_bits bits.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">var</span> out_bit_index<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">while</span> (out_bit_index <span style="color:#ff79c6">&lt;</span> prefix_bits) <span style="color:#ff79c6">:</span> (out_bit_index <span style="color:#ff79c6">+=</span> <span style="color:#bd93f9">1</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> (current.len() <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.NoCandidatePaths;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">const</span> root_bit<span style="color:#ff79c6">:</span> u1 <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@truncate</span>(current.get(<span style="color:#bd93f9">0</span>).lineage <span style="color:#ff79c6">&gt;&gt;</span> (L <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> (std.debug.runtime_safety) {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">for</span> (current.paths.items) <span style="color:#ff79c6">|</span>p<span style="color:#ff79c6">|</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">const</span> rb<span style="color:#ff79c6">:</span> u1 <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@truncate</span>(p.lineage <span style="color:#ff79c6">&gt;&gt;</span> (L <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>));
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">if</span> (rb <span style="color:#ff79c6">!=</span> root_bit) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.AmbiguousOutputBit;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                writeBit(out, out_bit_index, root_bit);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// Advance one step.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                next.clearRetainingCapacity();
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">for</span> (current.paths.items) <span style="color:#ff79c6">|</span>path<span style="color:#ff79c6">|</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">for</span> (<span style="color:#bd93f9">0</span>..<span style="color:#bd93f9">2</span>) <span style="color:#ff79c6">|</span>b_usize<span style="color:#ff79c6">|</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">const</span> bit_is_one <span style="color:#ff79c6">=</span> b_usize <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">const</span> header <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">if</span> (bit_is_one) state_change(path.header) <span style="color:#ff79c6">else</span> state_change(<span style="color:#ff79c6">~</span>path.header);
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">if</span> (self.filter.contains(header)) {
</span></span><span style="display:flex;"><span>                            <span style="color:#ff79c6">const</span> b<span style="color:#ff79c6">:</span> Lineage <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@as</span>(Lineage, <span style="color:#8be9fd;font-style:italic">@intCast</span>(b_usize));
</span></span><span style="display:flex;"><span>                            <span style="color:#ff79c6">const</span> lin<span style="color:#ff79c6">:</span> Lineage <span style="color:#ff79c6">=</span> (path.lineage <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">|</span> b;
</span></span><span style="display:flex;"><span>                            <span style="color:#ff79c6">try</span> next.addPath(header, lin);
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                std.mem.swap(<span style="color:#8be9fd;font-style:italic">@TypeOf</span>(current), <span style="color:#ff79c6">&amp;</span>current, <span style="color:#ff79c6">&amp;</span>next);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// Append last L bits from the correct final path.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">const</span> shiftType <span style="color:#ff79c6">=</span> getLog2Type(Lineage);
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">for</span> (current.paths.items) <span style="color:#ff79c6">|</span>path<span style="color:#ff79c6">|</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> (path.header <span style="color:#ff79c6">==</span> final_chain_header) {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">for</span> (<span style="color:#bd93f9">0</span>..L) <span style="color:#ff79c6">|</span>i<span style="color:#ff79c6">|</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">const</span> shift<span style="color:#ff79c6">:</span> shiftType <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@truncate</span>((L <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">-</span> i);
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">const</span> bit<span style="color:#ff79c6">:</span> u1 <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@truncate</span>(path.lineage <span style="color:#ff79c6">&gt;&gt;</span> shift);
</span></span><span style="display:flex;"><span>                        writeBit(out, prefix_bits <span style="color:#ff79c6">+</span> i, bit);
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">return</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.PathNotFound;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> paths(<span style="color:#ff79c6">comptime</span> lineageType<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">type</span>, <span style="color:#ff79c6">comptime</span> headerType<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">type</span>) <span style="color:#8be9fd">type</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> Allocator <span style="color:#ff79c6">=</span> std.mem.Allocator;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> Path <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">struct</span> { header<span style="color:#ff79c6">:</span> headerType, lineage<span style="color:#ff79c6">:</span> lineageType };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> Self <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@This</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        allocator<span style="color:#ff79c6">:</span> Allocator,
</span></span><span style="display:flex;"><span>        paths<span style="color:#ff79c6">:</span> std.ArrayList(Path) <span style="color:#ff79c6">=</span> .{},
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> init(allocator<span style="color:#ff79c6">:</span> Allocator) Self {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> .{ .allocator <span style="color:#ff79c6">=</span> allocator, .paths <span style="color:#ff79c6">=</span> .{} };
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> deinit(self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span>Self) <span style="color:#8be9fd">void</span> {
</span></span><span style="display:flex;"><span>            self.paths.deinit(self.allocator);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> clearRetainingCapacity(self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span>Self) <span style="color:#8be9fd">void</span> {
</span></span><span style="display:flex;"><span>            self.paths.clearRetainingCapacity();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> addPath(self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span>Self, h<span style="color:#ff79c6">:</span> headerType, l<span style="color:#ff79c6">:</span> lineageType) <span style="color:#ff79c6">!</span><span style="color:#8be9fd">void</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">try</span> self.paths.append(self.allocator, .{ .header <span style="color:#ff79c6">=</span> h, .lineage <span style="color:#ff79c6">=</span> l });
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> len(self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> Self) <span style="color:#8be9fd">usize</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> self.paths.items.len;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">fn</span> get(self<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> Self, i<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>) <span style="color:#ff79c6">*</span><span style="color:#ff79c6">const</span> Path {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>self.paths.items[i];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">fn</span> roundUp(x<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>, multiple<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>) <span style="color:#ff79c6">!</span><span style="color:#8be9fd">usize</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (multiple <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.InvalidPacketPayload;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> ((x <span style="color:#ff79c6">+</span> multiple <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">/</span> multiple) <span style="color:#ff79c6">*</span> multiple;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">/// Computes the filter size in **bytes** (rounded up) for the k=1 simplified filter,
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">/// while accounting for a packet loss rate `loss_rate`.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">fn</span> computeFilterSizeK1WithLoss(n_bits<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>, loss_rate<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span>, p_eff<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span>) <span style="color:#ff79c6">!</span><span style="color:#8be9fd">usize</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (n_bits <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.InvalidMessageLength;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>(loss_rate <span style="color:#ff79c6">&gt;=</span> <span style="color:#bd93f9">0.0</span> <span style="color:#ff79c6">and</span> loss_rate <span style="color:#ff79c6">&lt;</span> <span style="color:#bd93f9">1.0</span>)) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.InvalidLossRate;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>(p_eff <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">0.0</span> <span style="color:#ff79c6">and</span> p_eff <span style="color:#ff79c6">&lt;</span> <span style="color:#bd93f9">0.5</span>)) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.InvalidFPR;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>(p_eff <span style="color:#ff79c6">&gt;</span> loss_rate)) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.ImpossibleParameters;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> n_f<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@floatFromInt</span>(n_bits);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> ratio<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span> <span style="color:#ff79c6">=</span> (<span style="color:#bd93f9">1.0</span> <span style="color:#ff79c6">-</span> p_eff) <span style="color:#ff79c6">/</span> (<span style="color:#bd93f9">1.0</span> <span style="color:#ff79c6">-</span> loss_rate);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> root<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@exp</span>(<span style="color:#8be9fd;font-style:italic">@log</span>(ratio) <span style="color:#ff79c6">/</span> n_f);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> denom<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span> <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1.0</span> <span style="color:#ff79c6">-</span> root;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>(denom <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">0.0</span>)) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">error</span>.ImpossibleParameters;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> m_bits_f<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">f64</span> <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1.0</span> <span style="color:#ff79c6">/</span> denom;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> m_bits<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@intFromFloat</span>(<span style="color:#8be9fd;font-style:italic">@ceil</span>(m_bits_f));
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> (m_bits <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">7</span>) <span style="color:#ff79c6">/</span> <span style="color:#bd93f9">8</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">fn</span> writeBit(out<span style="color:#ff79c6">:</span> []<span style="color:#8be9fd">u8</span>, bit_index<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span>, bit<span style="color:#ff79c6">:</span> u1) <span style="color:#8be9fd">void</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> byte_index<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">usize</span> <span style="color:#ff79c6">=</span> bit_index <span style="color:#ff79c6">/</span> <span style="color:#bd93f9">8</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> bit_in_byte<span style="color:#ff79c6">:</span> u3 <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@intCast</span>(<span style="color:#bd93f9">7</span> <span style="color:#ff79c6">-</span> (bit_index <span style="color:#ff79c6">%</span> <span style="color:#bd93f9">8</span>)); <span style="color:#6272a4">// msb-first
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">const</span> mask<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">u8</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@as</span>(<span style="color:#8be9fd">u8</span>, <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">&lt;&lt;</span> bit_in_byte;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (bit <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1</span>) out[byte_index] <span style="color:#ff79c6">|=</span> mask;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pub</span> <span style="color:#ff79c6">inline</span> <span style="color:#ff79c6">fn</span> getLog2Type(<span style="color:#ff79c6">comptime</span> T<span style="color:#ff79c6">:</span> <span style="color:#8be9fd">type</span>) <span style="color:#8be9fd">type</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">comptime</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> (<span style="color:#8be9fd;font-style:italic">@typeInfo</span>(T).int.signedness <span style="color:#ff79c6">!=</span> .unsigned) <span style="color:#8be9fd;font-style:italic">@compileError</span>(<span style="color:#f1fa8c">&#34;getLog2Type: T must be an unsigned integer type&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> bits <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@typeInfo</span>(T).int.bits;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> (bits <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">or</span> (bits <span style="color:#ff79c6">&amp;</span> (bits <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>)) <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">0</span>) <span style="color:#8be9fd;font-style:italic">@compileError</span>(<span style="color:#f1fa8c">&#34;getLog2Type: bit-width must be a power of two&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">const</span> log2_bits <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">@log2</span>(<span style="color:#8be9fd;font-style:italic">@as</span>(<span style="color:#8be9fd">f16</span>, bits));
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">@Type</span>(.{
</span></span><span style="display:flex;"><span>            .int <span style="color:#ff79c6">=</span> .{
</span></span><span style="display:flex;"><span>                .signedness <span style="color:#ff79c6">=</span> .unsigned,
</span></span><span style="display:flex;"><span>                .bits <span style="color:#ff79c6">=</span> log2_bits,
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
  </div>
</div>

<h2 id="the-role-of-the-chain-header">The role of the chain header <a href="#the-role-of-the-chain-header" class="anchor">üîó</a></h2><p>Earlier, we noted that the chain header bit size directly affects Information Chaining performance.<br>
You might now ask: ‚ÄúWhy use a multi-bit chain header at all? Couldn‚Äôt we just make random changes to a single bit instead?‚ÄùSurprisingly, the answer is <strong>no</strong>, and the reason is subtle. Think of the chain header as an <strong>identifier</strong> for a path within the decoding tree. If two candidate paths (say, the correct path and a wrong path) ever share the same chain header at the same depth, they will evolve identically from that point onward, meaning the wrong path can <em>never</em> be pruned. In other words, the chain header must carry enough information to uniquely distinguish all candidate paths that might exist at a given depth. If you expect only a few candidates per iteration, a small header suffices. But if you expect many candidates, for instance, when aiming for minimal space overhead at a given loss rate, you‚Äôll need a larger, more information-rich chain header. This dynamic might seem obvious in hindsight, but it elegantly ties together randomness, redundancy, and recoverability.</p>
<h1 id="reflection-and-teasers">Reflection and teasers <a href="#reflection-and-teasers" class="anchor">üîó</a></h1><p>While neat in concept, the erasure code I presented has several clear shortcomings.</p>
<p>The first issue is <strong>bandwidth overhead</strong>. With regular Bloom filters and a false positive rate of, say, $0.49$, we‚Äôd need to transmit roughly 1.76√ó as many bits as in the original message just to tolerate a 10% packet loss rate. While better than retransmission, that‚Äôs still a steep cost for an erasure code. Using <a href="https://web.archive.org/web/20220620080435/https://giovanni.bajo.it/post/47119962313/golomb-coded-sets-smaller-than-bloom-filters" target="_blank" rel="noopener">Golomb Coded Sets</a> brings the overhead down somewhat, and combining Bloom filter‚Äìbased Information Chaining with a peeling algorithm can reduce it even further (while increasing decoding time). But even those numbers still fall short compared to state-of-the-art erasure codes used in modern streaming systems.</p>
<p>The second issue lies in <strong>memory and latency performance</strong>. Even with heavy optimization such as SIMD, Bloom filter‚Äìbased Information Chaining involves a lot of random memory access, leading to frequent cache misses. And perhaps more problematic, its probabilistic nature causes branch formation during decoding even when no erasures are present. While wrong branches are pruned quickly, ideally they shouldn‚Äôt appear at all unless data is actually missing.</p>
<p>Although these critiques sound harsh, the core idea of Information Chaining still holds remarkable promise. Good engineering isn‚Äôt just about dismantling ideas quickly, it‚Äôs about recognizing the <em>fragments of potential</em> within them. When I first conceived of Information Chaining more than a year ago, I had little more than a gut feeling that there was something special about it. Since then, through countless iterations and prototypes, we‚Äôve developed versions that not only surpass traditional approaches like RaptorQ codes (we‚Äôll explore Raptor codes in upcoming posts), but do so on an entirely new performance frontier.</p>
<p>Going forward, I plan to maintain this tinkering-driven approach throughout the series. The goal isn‚Äôt to unveil the final, polished version of Information Chaining right away, but to guide you, the reader, through the same process of exploration we went through. By the end, I want you to feel like you‚Äôve arrived at the concept yourself.</p>
<p>In this first post, we planted the seed: the foundational idea of Information Chaining. Part Two will introduce the next stage, a more efficient, probabilistic Information Chaining variant that reduces bandwidth overhead and eliminates the need for approximate membership query filters like Bloom filters. Part Three will unveil collision-free Information Chaining, a version that forms decoding branches only in the presence of erasures, dramatically improving both memory efficiency and latency. We‚Äôll also introduce the benefits of fountain codes in this context. Part Four will cover Rapid Information Chaining, the FPGA/ASIC-friendly incarnation with stunning speed, minimal memory footprint, and an exceptional overhead-to-loss ratio. Finally, Part Five will explore Gaussian-based Information Chaining, a non-probabilistic Information Chaining variant, that achieves more favorable computational complexity in regimes where erasures are frequent or extensive.</p>
<hr>
<h1 id="how-to-cite-this-work">How to Cite This Work <a href="#how-to-cite-this-work" class="anchor">üîó</a></h1><p>If you enjoyed this post, consider sharing it with others who might find it valuable, knowledge grows when shared. Curious about our work or interested in collaborating? <a href="mailto:lum@opencybernetics.io">Drop me a line</a>. I&rsquo;m always eager to connect with like-minded innovators.</p>
<p>If you‚Äôd like to reference this article in your own research or writing, please cite it as follows:</p>
<blockquote>
<p><strong>Lum Ramabaja (2026).</strong> <em>Let It Bloom: The Seeds of Information Chaining (Part 1).</em><br>
Open Cybernetics Blog. <a href="https://lumramabaja.com/post/information_chaining_part_1/" target="_blank" rel="noopener">https://lumramabaja.com/post/information_chaining_part_1/</a></p>
</blockquote>
<p>You can also cite it in <strong>BibTeX</strong> format:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bibtex" data-lang="bibtex"><span style="display:flex;"><span><span style="color:#50fa7b">@article</span>{<span style="color:#8be9fd;font-style:italic">ramabaja2025informationchaining1</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#50fa7b">title</span>   = <span style="color:#f1fa8c">{Let It Bloom: The Seeds of Information Chaining (Part 1)}</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#50fa7b">author</span>  = <span style="color:#f1fa8c">{Ramabaja, Lum}</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#50fa7b">year</span>    = <span style="color:#f1fa8c">{2026}</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#50fa7b">journal</span> = <span style="color:#f1fa8c">{Open Cybernetics Blog}</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#50fa7b">url</span>     = <span style="color:#f1fa8c">{https://lumramabaja.com/post/information_chaining_part_1/}</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
    </div>

    
        <div class="tags">
            
                <a href="https://lumramabaja.com/tags/open-cybernetics">Open Cybernetics</a>
            
                <a href="https://lumramabaja.com/tags/information-chaining">Information Chaining</a>
            
                <a href="https://lumramabaja.com/tags/bloom-filter">Bloom Filter</a>
            
                <a href="https://lumramabaja.com/tags/erasure-code">Erasure Code</a>
            
        </div>
    
    
    
  <div id="comment">
    
    
  </div>


</section>


    </main>
    
    <footer id="footer">
    
        <div id="social">


    <a class="symbol" href="https://github.com/ChainlessCoder" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28"  viewBox="0 0 72 72" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    
    <title>Github</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)">
            <g id="Github" transform="translate(264.000000, 939.000000)">
                <path d="M8,72 L64,72 C68.418278,72 72,68.418278 72,64 L72,8 C72,3.581722 68.418278,-8.11624501e-16 64,0 L8,0 C3.581722,8.11624501e-16 -5.41083001e-16,3.581722 0,8 L0,64 C5.41083001e-16,68.418278 3.581722,72 8,72 Z" id="Rounded" fill="#bbbbbb"></path>
                <path d="M35.9985,13 C22.746,13 12,23.7870921 12,37.096644 C12,47.7406712 18.876,56.7718301 28.4145,59.9584121 C29.6145,60.1797862 30.0525,59.4358488 30.0525,58.7973276 C30.0525,58.2250681 30.0315,56.7100863 30.0195,54.6996482 C23.343,56.1558981 21.9345,51.4693938 21.9345,51.4693938 C20.844,48.6864054 19.2705,47.9454799 19.2705,47.9454799 C17.091,46.4500754 19.4355,46.4801943 19.4355,46.4801943 C21.843,46.6503662 23.1105,48.9634994 23.1105,48.9634994 C25.2525,52.6455377 28.728,51.5823398 30.096,50.9649018 C30.3135,49.4077535 30.9345,48.3460615 31.62,47.7436831 C26.2905,47.1352808 20.688,45.0691228 20.688,35.8361671 C20.688,33.2052792 21.6225,31.0547881 23.1585,29.3696344 C22.911,28.7597262 22.0875,26.3110578 23.3925,22.9934585 C23.3925,22.9934585 25.4085,22.3459017 29.9925,25.4632101 C31.908,24.9285993 33.96,24.6620468 36.0015,24.6515052 C38.04,24.6620468 40.0935,24.9285993 42.0105,25.4632101 C46.5915,22.3459017 48.603,22.9934585 48.603,22.9934585 C49.9125,26.3110578 49.089,28.7597262 48.8415,29.3696344 C50.3805,31.0547881 51.309,33.2052792 51.309,35.8361671 C51.309,45.0917119 45.6975,47.1292571 40.3515,47.7256117 C41.2125,48.4695491 41.9805,49.9393525 41.9805,52.1877301 C41.9805,55.4089489 41.9505,58.0067059 41.9505,58.7973276 C41.9505,59.4418726 42.3825,60.1918338 43.6005,59.9554002 C53.13,56.7627944 60,47.7376593 60,37.096644 C60,23.7870921 49.254,13 35.9985,13" fill="#FFFFFF"></path>
            </g>
        </g>
    </g>
</svg>
    </a>


</div>

    

    <div class="copyright">
    
       ¬© Copyright 
       2026 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       Lum Ramabaja
    
    </div>

    
</footer>



  </body>
</html>
